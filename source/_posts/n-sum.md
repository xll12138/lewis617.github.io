---
title: 数组搜索算法题：求和为定值的多个数
date: 2017-03-09 18:06:00
tags: [数据结构与算法]
---

在[《JavaScript 版数据结构与算法（九）排序和搜索》](https://lewis617.github.io/2017/02/20/sort-and-search/)一文中，我们讲解了冒泡排序、选择排序、插入排序、归并排序、快速排序、顺序搜索、二分搜索等常见排序和搜索算法。今天，我们要讲的是一道数组搜索算法题：**求和为定值的多个数**。这道数组搜索算法题可以看作是前面介绍的搜索算法的拓展，而且我把该题的示例代码也写进了前面编写的 `ArrayList` 这个类中。让我们一起来看一下这道题的 JavaScript 实现方法吧！

<!--more-->

## 题目

这道题的题目是：给定一个无序不重复的数组，求数组中和为 `M` 的 `N` 个数。我们依然先编写测试代码来表达需求：

```js
function createNonSortedArray() {
  var array = new ArrayList();
  array.insert(1);
  array.insert(3);
  array.insert(5);
  array.insert(4);
  array.insert(2);
  return array;
}

var array = createNonSortedArray();

// 对于数组 [1, 3, 5, 4, 2] 而言，和为6的2个数为 [1, 5] 和 [2, 4]
expect(array.NSum(2, 6)).toEqual([[1, 5], [2, 4]]);
// 和为7的3个数为 [1, 2, 4]
expect(array.NSum(3, 7)).toEqual([[1, 2, 4]]);
// 和为14的4个数为 [2, 3, 4, 5]
expect(array.NSum(4, 14)).toEqual([[2, 3, 4, 5]]);
```

通过上面的测试代码，我们知道首先要编写一个 `ArrayList` 类，该类包含一个 `insert` 方法可以插入数据。这些工作前面我们都已经做过了，如果你不记得，可以先复习一下前面的博文：[《JavaScript 版数据结构与算法（九）排序和搜索》](https://lewis617.github.io/2017/02/20/sort-and-search/)。我们现在需要做的仅仅就是编写类方法 `NSum`，该类方法接受 `N` 和 `M` 作为参数，返回满足要求的数组。

## 分析

看完了题目，我们来分析一下如何解题。对于数组搜索算法而言，如果搜索一个数，那么方法就是前面讲的：

- 顺序搜索
- 二分搜索

这非常简单，那么如果搜索和为定值两个数呢？其实也可以是顺序搜索或二分搜索，只不过需要遍历数组，先拿到一个值，然后对另一个值进行顺序搜索或二分搜索，比如 `[1, 3, 5, 4, 2]`，求和为6的两个数，那么：

- 第一轮取1，对 `[3, 5, 4, 2]` 进行顺序搜索或二分搜索
- 第二轮取3，对 `[5, 4, 2]`  进行顺序搜索或二分搜索
- ……

使用顺序搜索查找两个数的时间复杂度为O(n^2)，空间复杂度为O(1)。使用二分搜索的时间复杂度为O(nlogn)，空间复杂度为O(1)。

那么除了顺序搜索和二分搜索，还有别的方法吗？答案是肯定的。其他方法列举如下：

- **借助散列表**：先构建一个散列表，存储数组每个值。然后遍历数组，查看 `M` 与每项的差是否在散列表中，如果在就返回两个值。这个方法的时间复杂度和空间复杂度均为O(n)。
- **双指针两端扫描**：若数组无序，就先排序后扫描。扫描方法是用两个指针 `i` 和 `j`，先放在数组首尾，如果指向的两个数之和大于 `M` ，就 `j--`，否则 `i++`，直到两个数之和为 `M`，然后返回这两个数。该方法的时间复杂度最后为：有序O(n)，无序O(nlogn + n)=O(nlogn)，空间复杂度都为O(1)。

这两个方法的代码这里不再展示，因为我们主要讲解和为定值的多个数的搜索方法。有兴趣的话可以自行搜索，网上有非常多的示例。

了解了和为定值的两个数的搜索方法，那么和为定值的多个数（大于2）的搜索方法呢？这里需要用到**遍历**+**递归算法**！先举个例子吧！比如数组为 `[1, 3, 5, 4, 2]` ，`M` 为7，`N`为3。那么整个流程如下：

- 第一轮取1，对 `[3, 5, 4, 2]` 进行 `M` 为7-1，`N`为3-1的搜索。
- 第二轮取3，对 `[5, 4, 2]` 进行 `M` 为7-1，`N`为3-1的搜索。
- ……

当 `N` 为2，那么我们就可以用前面介绍的方法了！如果 `N` 为更大的值，那么就使用**递归**，一直到 `N` 为2时终结掉。分析得差不多了，让我们使用最爱的 JavaScript 来实现这个搜索算法吧！

## 代码

通过上面的分析，我们知道我们需要一个函数来进行数组、`M` 和 `N`的处理，该函数也会被递归直到 `N` 为2的来临！上代码：

```js
var findNSum = function (nums, M, N, result, results) {
  if (nums.length < N || M < nums[0] * N || M > nums[-1] * N) {  // 异常处理
    return;
  }
  if (N === 2) {  // 递归的终结
    var l = 0,
      r = nums.length - 1;
    while (l < r) {
      var s = nums[l] + nums[r];
      if (s === M) {
        results.push(result.concat([nums[l], nums[r]]));
        l++;
      } else if (s < M) {
        l++;
      } else {
        r--;
      }
    }
  } else {
    for (var i = 0; i < nums.length - N + 1; i++) {  // 遍历+递归
      findNSum(nums.slice(i + 1), M - nums[i], N - 1, result.concat([nums[i]]), results);
    }
  }
};
```

这个函数接受`nums, M, N, result, results` 五个参数，前三个自不用多解释，那么后两个参数是啥？`result` 是个数组，用于盛放满足条件的多个数，`results` 也是个数组，用于盛放所有满足条件的 `result` 数组。编写好了上述函数，我们只需要在类方法中启动它，就可以完成任务了：

```js
this.NSum = function (N, M) {
  this.quickSort();

  var results = [];
  findNSum(array, M, N, [], results);
  return results;
};
```

至此，算法就写完了！

## 教程源代码及目录

https://github.com/lewis617/javascript-datastructures-algorithms